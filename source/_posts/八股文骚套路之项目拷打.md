---
title: 八股文骚套路之项目拷打
abbrlink: 824f9b28
date: 2024-09-22 09:53:54
tags:
---

## 介绍一下项目

- 一个本地校园生活服务平台，为学校学生提供线上论坛、线上商城。

- 由springboot开发的前后端分类项目，使用了redis集群和tomcat集群和mysql集群来提高服务器的性能

- 项目的技术栈是springboot+nginx+mysql+lombok+mybatis+hutool+redis

## 短信登录功能

### 初次登录

注册之后，校验用户登陆提交的手机号和验证码，然后根据手机号查询用户信息，不存在则创建，然后将用户信息保存到redis，以生成的token作为redis的key。

### 校验登录状态

用户携带token进行访问，从redis中取出token对应的value，判断是否存在这个数据，如果没有则拦截，如果存在则将其保存到**threadLocal**中，并且放行。

> [!TIP]
> 因为不同服务器之间的session无法共享，使用redis可以实现数据共享
> 将部分可展示属性封装成dto单独传递

### 双重拦截器？

浏览需要验证身份的模块时，在这些模块的共同的拦截器中刷新token。

但是有些页面不需要验证登录状态，但是也要刷新token，所以新添加一层拦截器用来刷新token有效期，避免出现token过期用户需要重新登录

### threadLocal是干什么用的？

## 商户缓存功能

使用redis来缓存商户商品信息，提升访问速度

查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回

如果缓存数据不存在，再查询数据库，然后将数据存入redis。

这就自然的引出了下面两个问题

### 缓存与数据库的数据一致性问题及其解决方案

使用延迟双删方案

- 查询时如果缓存未命中，则查询数据库，将数据库结果写入缓存，并设置超时时间
- 修改时先修改数据库，再删除缓存。等下一次再来查询数据时，再从数据库中加载到缓存中

<!-- TODO: 为什么要使用延迟双删方案？ -->

### 使用缓存空值和布隆过滤器缓存穿透问题

- 客户端请求的数据再数据库和缓存中都不存在

- 缓存空值：如果查询的数据数据库中没有，那么就在缓存中缓存一个空对象，下次再来查的时候就不会找到数据库了，在缓存中发现是空值则直接结束查询

- 自定义布隆过滤器：在缓存之前添加一个布隆过滤器，提前将用户可能查询的数据放在过滤器里，用hash思想判断数据是否存在，但是布隆过滤器会有误判可能（存在的不一定存在，不存在的一定不存在）

### 使用缓存预热解决缓存雪崩问题

- 同一时间大量缓存key同时失效或者redis服务器宕机导致大量请求同时到达数据库

- 针对redis宕机，可以使用reids集群和多级缓存

- 大量key同时失效，可以采用缓存预热：提前将热点key存入缓存中并设置合理的过期时间（这里可使用消息队列kafka，异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存）

## 使用rabbitmq消息队列实现优惠券秒杀功能，并通过乐观锁解决超卖问题，使用分布式锁解决一人一单问题

用户开始下单，我们要去查询秒杀资格（1. 用户有优惠券 2.库存充足）

### rabbitmq消息队列实现优惠券秒杀问题

秒杀需要查询优惠券，判断库存，查询用户是否下单，校验是否一人一单，扣减库存，创建订单这些步骤，很多操作是要操作数据库的，这样如果是一个线程串行执行就会很慢，因此只要确定它能做，而不需要立马做好，将判断和做分开执行，因此可以使用消息队列

- 将耗时比较短的逻辑判断放入到redis中，比如是否库存足够，比如是否一人一单，确认之后在后台开一个线程，实现异步下单。

### 乐观锁解决超卖问题

线程a来查库存，此时大于1，要去扣库存但还没来得及扣，此时线程b来查库存，发现也大于1，那么两个线程都去扣减库存，导致超卖

乐观锁：只在数据更新时判断有没有其他线程对数据进行了修改

- 操作的时候对数据的版本号进行+1 只有当版本号不变的时候才能操作，假设线程a操作之后，version号从1变成了2，那么线程2操作的时候发现version != 1 因此不能操作

### 使用分布式锁解决一人一单问题

分布式锁：满足分布式系统或者集群模式下多线程可见并且互斥。

1. 分布式系统 集群模式

2. 多线程可见 互斥

redis的setNx方法，当多个线程过来抢优惠券，第一个线程抢到锁之后，去执行业务，然后删除释放锁，其他线程等待并重试

> [!TIP]
> 利用setnx的方法加锁，同时设置过期时间，防止死锁
> 如果持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁，因此在删除锁之前要判断这把锁是不是自己的

综上：使用redisson分布式锁替代setnx解决这些问题

## 压测的时候主要关注的指标

- 并发量
- 响应时间
- 错误率
- 吞吐量
  - QPS：每秒能够处理的查询数量
  - TPS：每秒能够处理的事务数量
- 资源使用率
