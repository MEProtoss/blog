---
title: 八股文骚套路之mysql
abbrlink: c53b31d1
date: 2024-09-20 17:05:20
tags:
---

## ORDER BY、LIMIT、GROUP BY、HAVING 这些关键字的作用

- order by：排序
- limit: 限制查询返回的行数
- group by：根据一个或多个列对查询结果分组
- having: 用于过滤分组后的数据
  - 相比较where:HAVING 在分组后应用条件，而 WHERE 在分组前应用条件

## 左链接和右链接的区别

一个以左边的表为基础，确保左表中的行都出现在结果中,反之亦然

## InnoDB(mysql数据库管理系统的一个存储引擎)相关

索引的本质是一种排序好的数据结构

### InnoDB 和 MyISAM 的区别是什么

- InnoDB 支持行级锁，MyISAM只有表级锁
- MyISAM 不提供事务支持。
- InnoDB 提供事务支持，MyISAM不支持。
- MyISAM 不支持外键，而 InnoDB 支持。
- MyISAM 不支持 MVCC，而 InnoDB 支持。
- 虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。
- MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。
- InnoDB 的性能比 MyISAM 更强大

## 索引相关

### 索引所采用的数据结构，以及为什么要这样设计

常见的索引结构有:

- **hash表** 不支持顺序和范围查询
- 红黑树
- **B树**
- **B+树**
  - 节点存放key，叶子存放key和data
  - 叶子节点有一条引用鲢指向与他相邻的叶子节点
  - 任何查找都是从根节点到叶子节点的过程，检索效率稳定
  - B+树的范围查找只需要对叶子节点作范围查询
- 二叉查找树(左小右大)
- 平衡二叉树(优化的二叉查找树 左右子树高度之差不超过 1)

### BTree 索引和 Hash 索引的适用范围

InnoDB数据库和MyISM数据库默认使用BTree索引

- hash索引适用于**等值查询**，尤其是在**内存密集**的环境中；
- 不适用于范围查询、排序和处理大量哈希冲突的情况

## SQL优化问题

### 哪些场景可以使用索引

- 排序
- 连接操作
- 唯一性约束
- 聚集函数
- 范围查询
- 避免全表查询

### 索引在哪些情况会失效

- 不能对索引列进行查询和函数操作
- 数据分布不均匀
- 数据量很大
- 频繁更新的列
- 索引列参与复杂的表达式或者条件

## 事务四大特性，并解释这四大特性的含义

ACID

- 原子性 事务是最小执行单位，不允许分割
- 一致性 执行事务前后 数据保持一致
- 隔离性 并发访问数据库时，一个用户的事务不被其他事务所干扰
- 持久性 事务提交之后对数据库的影响是永久的

只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！

## 并发事务处理会带来哪些问题？

- 脏读 a读到了b修改未提交的数据
- 幻读 a多次读同一个数据，但是期间其他事务对数据进行了修改
- 丢失修改 a读一个数据，b也访问该数据，第一个事务修改数据之后，b也修改了这个数据，导致a的修改结果丢失

## 事务隔离级别

- 读未提交 读取尚未提交的数据变更 会导致**脏读 不可重读 幻读**
- 读已提交 允许读取并发事务已经提交的数据 会导致**不可重读 幻读**
- 可重读 对同一字段的多次读取结果是一致的 会导致**幻读**
- 可串行化 满足acid

## InnoDB 行锁实现方式

- 共享锁(s)（读锁）和排它锁(x)（写锁）
- MVCC（多版本并发控制）MVCC可以在**读取数据时不加锁**，同时保证事务的一致性。每个事务在开始时都会生成一个唯一的事务ID，每行数据也会保存这个事务ID的版本信息。这样，即使其他事务在修改数据，当前事务也可以读取到之前版本的数据。

- MVCC（多版本并发控制） 是一种**并发控制机制**，通过**在每个数据行上维护多个版本的数据**，当一个事务要对数据库中的数据进行修改的时候，MVCC会为该事务创建一个数据快照，而不是直接修改实际的数据行，用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性

**读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用**

## 你了解 Next-key 锁吗？

Next-Key锁是一种特殊类型的锁，通常在实现范围查询时用于避免幻读（Phantom Read）问题。

Next-Key锁结合了行锁（Row Lock）和间隙锁（Gap Lock）的特性，用于确保范围查询的一致性。

- 普通select读取的时候读取mvcc的快照
- 使用当前读的时候读取最新数据，并且防止其他事务在查询范围内插入数据

## 如何避免 InnoDB 中的死锁

- **尽量使用索引**
- **使用事务的隔离级别**
- 减少并发
- 合理设计事务

## 死锁的类型

死锁是指多个事务在相互持有资源的情况下，同时等待对方释放资源

- 简单死锁
涉及两个事务，互相等待

- 递归死锁
多个事务，循环等待

- 资源不足死锁
资源紧张的情况下，多个事务由于资源不足进入等待

## 如何优化数据库？

- 索引
- 分库分表: 就是将数据库中的数据分散到不同的数据库上,是对单表的数据进行拆分。
- 读写分离：将对数据库的读写操作分散到不同的数据库节点
- 数据冷热分离:根据数据的访问频率和业务重要性，将数据分为冷数据和热数据，冷数据一般存储在存储在低成本、低性能的介质中，热数据存放在高性能存储介质中。

## 数据库中的乐观锁和悲观锁，以及适用场景？

- 悲观锁：假设并发访问会导致冲突，因此在**访问数据之前获取锁**，以防止别的事务对数据进行修改,**适用于频繁写的场景**。（例如数据库中的行级锁和表级锁）

- 乐观锁：假设并发访问不会导致冲突，因此在访问数据时不会立即获取锁，**在更新数据时检查数据是否被其他事务修改过**，如果没有则进行更新，否则会进行回滚或者重试。**适用于读操作多，写操作少的场景**
